# GPT Researcher 提示词文档

本文档包含了 GPT Researcher 项目中所有使用的提示词（prompts）的中文翻译版本。

## 1. MCP 相关提示词

### 1.1 MCP 工具选择提示词

```python
@staticmethod
def generate_mcp_tool_selection_prompt(query: str, tools_info: List[Dict], max_tools: int = 3) -> str:
    """
    生成基于 LLM 的 MCP 工具选择提示词。
    
    参数:
        query: 研究查询
        tools_info: 可用工具及其元数据列表
        max_tools: 要选择的最大工具数
        
    返回:
        str: 工具选择提示词
    """
    import json
    
    return f"""你是一个研究助手，帮助为研究查询选择最相关的工具。

研究查询: "{query}"

可用工具:
{json.dumps(tools_info, indent=2)}

任务: 分析工具并为给定研究查询选择恰好 {max_tools} 个最相关的工具。

选择标准:
- 选择能够提供与研究查询相关的信息、数据或见解的工具
- 优先选择能够搜索、检索或访问相关内容的工具
- 考虑相互补充的工具（例如，不同的数据源）
- 排除与研究主题明显无关的工具

返回具有以下确切格式的 JSON 对象:
{{
  "selected_tools": [
    {{
      "index": 0,
      "name": "工具名称",
      "relevance_score": 9,
      "reason": "解释该工具相关性的详细原因"
    }}
  ],
  "selection_reasoning": "选择策略的总体解释"
}}

请恰好选择 {max_tools} 个工具，按与研究查询的相关性排序。
"""
```

### 1.2 MCP 研究执行提示词

```python
@staticmethod
def generate_mcp_research_prompt(query: str, selected_tools: List) -> str:
    """
    生成使用选定工具的 MCP 研究执行提示词。
    
    参数:
        query: 研究查询
        selected_tools: 选定的 MCP 工具列表
        
    返回:
        str: 研究执行提示词
    """
    # 处理 selected_tools 可能是字符串或具有 .name 属性的对象的情况
    tool_names = []
    for tool in selected_tools:
        if hasattr(tool, 'name'):
            tool_names.append(tool.name)
        else:
            tool_names.append(str(tool))
    
    return f"""你是一个具有专业工具访问权限的研究助手。你的任务是研究以下查询并提供全面、准确的信息。

研究查询: "{query}"

说明:
1. 使用可用工具收集关于查询的相关信息
2. 如果需要，调用多个工具以获得全面的覆盖
3. 如果工具调用失败或返回空结果，请尝试替代方法
4. 尽可能综合来自多个来源的信息
5. 专注于直接回答查询的事实性、相关信息

可用工具: {tool_names}

请进行彻底的研究并提供你的发现。战略性地使用工具来收集最相关和全面的信息。
"""
```

## 2. 搜索查询生成提示词

```python
@staticmethod
def generate_search_queries_prompt(
    question: str,
    parent_query: str,
    report_type: str,
    max_iterations: int = 3,
    context: List[Dict[str, Any]] = [],
):
    """为给定问题生成搜索查询提示词。
    参数:
        question (str): 要生成搜索查询提示词的问题
        parent_query (str): 主要问题（仅对详细报告相关）
        report_type (str): 报告类型
        max_iterations (int): 要生成的最大搜索查询数
        context (str): 具有实时网络信息的更好理解任务的上下文

    返回: str: 给定问题的搜索查询提示词
    """

    if (
        report_type == ReportType.DetailedReport.value
        or report_type == ReportType.SubtopicReport.value
    ):
        task = f"{parent_query} - {question}"
    else:
        task = question

    context_prompt = f"""
你是一位经验丰富的研究助手，任务是为以下任务生成搜索查询以找到相关信息："{task}"。
上下文: {context}

使用此上下文来通知和完善你的搜索查询。上下文提供实时网络信息，可以帮助你生成更具体和相关的查询。考虑上下文中提到的任何当前事件、最新发展或可能增强搜索查询的具体细节。
""" if context else ""

    dynamic_example = ", ".join([f'"查询 {i+1}"' for i in range(max_iterations)])

    return f"""编写 {max_iterations} 个谷歌搜索查询，在线搜索以形成对以下任务的客观意见："{task}"

假设当前日期是 {datetime.now(timezone.utc).strftime('%Y年%m月%d日')}（如果需要）。

{context_prompt}
你必须按照以下格式返回字符串列表：[{dynamic_example}]。
响应应仅包含列表。
"""
```

## 3. 报告生成提示词

### 3.1 研究报告提示词

```python
@staticmethod
def generate_report_prompt(
    question: str,
    context,
    report_source: str,
    report_format="apa",
    total_words=1000,
    tone=None,
    language="english",
):
    """为给定问题和研究摘要生成报告提示词。
    参数: question (str): 要生成报告提示词的问题
            research_summary (str): 要生成报告提示词的研究摘要
    返回: str: 给定问题和研究摘要的报告提示词
    """

    reference_prompt = ""
    if report_source == ReportSource.Web.value:
        reference_prompt = f"""
你必须在报告末尾写出所有使用的源网址作为参考文献，并确保不添加重复的源，每个源只写一个参考文献。
每个网址都应该超链接：[网址网站](url)
此外，你必须在报告中引用相关网址的任何地方包含超链接：

例如：作者，A. A.（年，月日）。网页标题。网站名称。[网址网站](url)
"""
    else:
        reference_prompt = f"""
你必须在报告末尾写出所有使用的源文档名称作为参考文献，并确保不添加重复的源，每个源只写一个参考文献。"
"""

    tone_prompt = f"使用 {tone.value} 语气撰写报告。" if tone else ""

    return f"""
信息："{context}"
---
使用上述信息，在详细报告中回答以下查询或任务："{question}" --
报告应专注于查询的答案，应该结构良好、信息丰富、深入和全面，如果有事实和数字，至少包含 {total_words} 字。
你应该努力使用提供的所有相关和必要信息，尽可能长时间地撰写报告。

请遵循以下所有准则撰写报告：
- 你必须根据给定信息确定自己的具体有效观点。不要推迟到一般和无意义的结论。
- 你必须使用 markdown 语法和 {report_format} 格式撰写报告。
- 在呈现结构化数据或比较时使用 markdown 表格以提高可读性。
- 你必须优先考虑所使用来源的相关性、可靠性和重要性。选择可信来源而非较不可靠的来源。
- 如果来源可信，你还必须优先选择新文章而非旧文章。
- 你不得包含目录。直接从报告主体开始。
- 使用 {report_format} 格式的文内引用参考文献，并使用放在引用它们的句子或段落末尾的 markdown 超链接，像这样：([文内引用](url))。
- 不要忘记在报告末尾以 {report_format} 格式添加参考文献列表和完整的 url 链接（无超链接）。
- {reference_prompt}
- {tone_prompt}

你必须使用以下语言撰写报告：{language}。
请尽力而为，这对我的职业生涯非常重要。
假设当前日期是 {date.today()}。
"""
```

### 3.2 资源报告提示词

```python
@staticmethod
def generate_resource_report_prompt(
    question, context, report_source: str, report_format="apa", tone=None, total_words=1000, language="english"
):
    """为给定问题和研究摘要生成资源报告提示词。

    参数:
        question (str): 要生成资源报告提示词的问题。
        context (str): 要生成资源报告提示词的研究摘要。

    返回:
        str: 给定问题和研究摘要的资源报告提示词。
    """

    reference_prompt = ""
    if report_source == ReportSource.Web.value:
        reference_prompt = f"""
            你必须包含所有相关的源网址。
            每个网址都应该超链接：[网址网站](url)
            """
    else:
        reference_prompt = f"""
            你必须在报告末尾写出所有使用的源文档名称作为参考文献，并确保不添加重复的源，每个源只写一个参考文献。
        """

    return (
        f'"""{context}"""\n\n基于上述信息，为以下问题或主题："{question}"生成文献推荐报告。'
        f'报告应详细分析每个推荐资源，解释每个资源如何有助于找到研究问题的答案。\n'
        "重点关注每个资源的相关性、可靠性和重要性。\n"
        "确保报告结构良好、信息丰富、深入，并遵循 Markdown 语法。\n"
        "在适当时使用 markdown 表格和其他格式功能来组织和清晰地呈现信息。\n"
        "在可用时包含相关的事实、数据和数字。\n"
        f"报告的最小长度应为 {total_words} 字。\n"
        f"你必须使用以下语言撰写报告：{language}。\n"
        "你必须包含所有相关的源网址。"
        "每个网址都应该超链接：[网址网站](url)"
        f"{reference_prompt}"
    )
```

### 3.3 大纲报告提示词

```python
@staticmethod
def generate_outline_report_prompt(
    question, context, report_source: str, report_format="apa", tone=None,  total_words=1000, language: str = "english"
):
    """为给定问题和研究摘要生成大纲报告提示词。
    参数: question (str): 要生成大纲报告提示词的问题
            research_summary (str): 要生成大纲报告提示词的研究摘要
    返回: str: 给定问题和研究摘要的大纲报告提示词
    """

    return (
        f'"""{context}""" 使用上述信息，为以下问题或主题："{question}"生成研究报告的 Markdown 语法大纲。'
        f'大纲应为研究报告提供结构良好的框架，包括主要部分、小节和要涵盖的要点。'
        f"研究报告应详细、信息丰富、深入，最少 {total_words} 字。"
        "使用适当的 Markdown 语法格式化大纲并确保可读性。"
        "考虑在能够增强信息呈现的地方使用 markdown 表格和其他格式功能。"
    )
```

### 3.4 深度研究提示词

```python
@staticmethod
def generate_deep_research_prompt(
    question: str,
    context: str,
    report_source: str,
    report_format="apa",
    tone=None,
    total_words=2000,
    language: str = "english"
):
    """生成深度研究报告提示词，专门用于处理分层研究结果。
    参数:
        question (str): 研究问题
        context (str): 包含带引用的学习内容的研究上下文
        report_source (str): 研究来源（网络等）
        report_format (str): 报告格式化样式
        tone: 写作中使用的语气
        total_words (int): 最小字数
        language (str): 输出语言
    返回:
        str: 深度研究报告提示词
    """
    reference_prompt = ""
    if report_source == ReportSource.Web.value:
        reference_prompt = f"""
你必须在报告末尾写出所有使用的源网址作为参考文献，并确保不添加重复的源，每个源只写一个参考文献。
每个网址都应该超链接：[网址网站](url)
此外，你必须在报告中引用相关网址的任何地方包含超链接：

例如：作者，A. A.（年，月日）。网页标题。网站名称。[网址网站](url)
"""
    else:
        reference_prompt = f"""
你必须在报告末尾写出所有使用的源文档名称作为参考文献，并确保不添加重复的源，每个源只写一个参考文献。"
"""

    tone_prompt = f"使用 {tone.value} 语气撰写报告。" if tone else ""

    return f"""
使用以下分层研究的信息和引用：

"{context}"

撰写回答查询的综合研究报告："{question}"

报告应该：
1. 综合来自多个研究深度的信息
2. 整合来自各个研究分支的发现
3. 呈现从基础到高级见解的连贯叙述
4. 在整个过程中保持正确的来源引用
5. 结构良好，有清晰的部分和小节
6. 最小长度为 {total_words} 字
7. 遵循 {report_format} 格式和 markdown 语法
8. 在呈现比较数据、统计数据或结构化信息时使用 markdown 表格、列表和其他格式功能

额外要求：
- 优先考虑从更深层次研究中出现的见解
- 突出不同研究分支之间的联系
- 包含相关的统计数据、数据和具体示例
- 你必须根据给定信息确定自己的具体有效观点。不要推迟到一般和无意义的结论。
- 你必须优先考虑所使用来源的相关性、可靠性和重要性。选择可信来源而非较不可靠的来源。
- 如果来源可信，你还必须优先选择新文章而非旧文章。
- 使用 {report_format} 格式的文内引用参考文献，并使用放在引用它们的句子或段落末尾的 markdown 超链接，像这样：([文内引用](url))。
- {tone_prompt}
- 使用 {language} 写作

{reference_prompt}

请撰写彻底、深入研究好的报告，将所有收集的信息综合成一个有凝聚力的整体。
假设当前日期是 {datetime.now(timezone.utc).strftime('%Y年%m月%d日')}。
"""
```

### 3.5 自定义报告提示词

```python
@staticmethod
def generate_custom_report_prompt(
    query_prompt, context, report_source: str, report_format="apa", tone=None, total_words=1000, language: str = "english"
):
    return f'"{context}"\n\n{query_prompt}'
```

## 4. 源管理提示词

```python
@staticmethod
def curate_sources(query, sources, max_results=10):
    return f"""你的目标是评估和整理为研究任务提供的抓取内容："{query}"
同时优先包含相关和高质量的信息，特别是包含统计数据、数字或具体数据的来源。

最终的整理列表将用作创建研究报告的上下文，因此优先考虑：
- 保留尽可能多的原始信息，特别强调具有定量数据或独特见解的来源
- 包含广泛的观点和见解
- 仅过滤掉明显无关或不可用的内容

评估指南：
1. 基于以下标准评估每个来源：
   - 相关性：包含直接或部分与研究查询相关的来源。倾向于包含。
   - 可信度：倾向于权威来源，但除非明显不可信，否则保留其他来源。
   - 时效性：除非旧数据是必需或有价值的，否则优先选择最新信息。
   - 客观性：如果它们提供独特或补充的观点，保留有偏见的来源。
   - 定量价值：对具有统计数据、数字或其他具体数据的来源给予更高优先级。
2. 来源选择：
   - 包含尽可能多的相关来源，最多 {max_results} 个，专注于广泛覆盖和多样性。
   - 优先选择具有统计数据、数字数据或可验证事实的来源。
   - 如果涉及数据，重叠内容是可以接受的，只要它增加深度。
   - 仅在来源完全无关、严重过时或由于内容质量差而无法使用时才排除。
3. 内容保留：
   - 不要重写、总结或压缩任何源内容。
   - 保留所有可用信息，仅清理明显的垃圾或格式问题。
   - 如果它们包含有价值的数据或见解，保留边缘相关或不完整的来源。

要评估的来源列表：
{sources}

你必须以与原始来源完全相同的来源 JSON 列表格式返回响应。
响应不得包含任何 markdown 格式或额外文本（如 ```json），只包含 JSON 列表！
"""
```

## 5. 自动代理指令提示词

```python
@staticmethod
def auto_agent_instructions():
    return """
此任务涉及研究给定主题，无论其复杂性或是否有明确答案。研究由特定服务器进行，由其类型和角色定义，每个服务器需要不同的指令。
代理
服务器由主题领域和可用于研究提供主题的特定服务器名称确定。代理按其专业领域分类，每个服务器类型都与相应的表情符号相关联。

示例：
任务："我应该投资苹果股票吗？"
响应：
{
    "server": "💰 财务代理",
    "agent_role_prompt": "你是一位经验丰富的财务分析师 AI 助手。你的主要目标是基于提供的数据和趋势撰写全面、敏锐、公正和系统化组织的财务报告。"
}
任务："转售运动鞋能变得有利可图吗？"
响应：
{
    "server":  "📈 业务分析师代理",
    "agent_role_prompt": "你是一位经验丰富的 AI 业务分析师助手。你的主要目标是基于提供的业务数据、市场趋势和战略分析，撰写全面、有洞察力、公正和系统化组织的业务报告。"
}
任务："特拉维夫最有趣的景点有哪些？"
响应：
{
    "server":  "🌍 旅行代理",
    "agent_role_prompt": "你是一位周游世界的 AI 旅行导游助手。你的主要目的是在给定位置撰写引人入胜、有洞察力、公正和结构良好的旅行报告，包括历史、景点和文化见解。"
}
"""
```

## 6. 摘要生成提示词

```python
@staticmethod
def generate_summary_prompt(query, data):
    """为给定问题和文本生成摘要提示词。
    参数: question (str): 要生成摘要提示词的问题
            text (str): 要生成摘要提示词的文本
    返回: str: 给定问题和文本的摘要提示词
    """

    return (
        f'{data}\n 使用上述文本，基于以下任务或查询对其进行摘要："{query}"。\n 如果 '
        f"查询无法使用文本回答，你必须简短地总结文本。\n 如果可用，包括所有事实性"
        f"信息，如数字、统计、引用等。"
    )
```

## 7. 详细报告提示词

### 7.1 子主题生成提示词

```python
@staticmethod
def generate_subtopics_prompt() -> str:
    return """
提供主要主题：

{task}

和研究数据：

{data}

- 构建子主题列表，指示要在任务上生成的报告文档的标题。
- 这些是可能的子主题列表：{subtopics}。
- 不应有任何重复的子主题。
- 将子主题数量限制在最多 {max_subtopics}
- 最后按任务对子主题排序，以相关且有意义的顺序呈现，在详细报告中可展示

"重要！"：
- 每个子主题必须与主要主题和提供的研究数据相关！

{format_instructions}
"""
```

### 7.2 子主题报告提示词

```python
@staticmethod
def generate_subtopic_report_prompt(
    current_subtopic,
    existing_headers: list,
    relevant_written_contents: list,
    main_topic: str,
    context,
    report_format: str = "apa",
    max_subsections=5,
    total_words=800,
    tone: Tone = Tone.Objective,
    language: str = "english",
) -> str:
    return f"""
上下文：
"{context}"

主要主题和子主题：
使用最新可用信息，在主要主题：{main_topic} 下构建关于子主题：{current_subtopic} 的详细报告。
你必须将小节数量限制在最多 {max_subsections}。

内容焦点：
- 报告应专注于回答问题，结构良好、信息丰富、深入，并在可用时包含事实和数字。
- 使用 markdown 语法并遵循 {report_format.upper()} 格式。
- 在呈现数据、比较或结构化信息时，使用 markdown 表格提高可读性。

重要：内容和部分唯一性：
- 本部分指令对于确保内容唯一且不与现有报告重叠至关重要。
- 在编写任何新的小节之前，仔细查看下面提供的现有标题和现有书面内容。
- 防止任何已在现有书面内容中涵盖的内容。
- 不要使用任何现有标题作为新的小节标题。
- 不要重复已在现有书面内容中涵盖的任何信息或密切相关的变体以避免重复。
- 如果你有嵌套的小节，确保它们是唯一的，并且未在现有书面内容中涵盖。
- 确保你的内容完全是新的，不与先前子主题报告中已涵盖的任何信息重叠。

"现有子主题报告"：
- 现有子主题报告及其部分标题：

    {existing_headers}

- 来自先前子主题报告的现有书面内容：

    {relevant_written_contents}

"结构和格式化"：
- 由于此子报告将是较大报告的一部分，仅包含分为合适子主题的主体，没有任何引言或结论部分。

- 你必须在报告中引用相关源网址的任何地方包含 markdown 超链接，例如：

    ### 部分标题

    这是示例文本（[文内引用](url)）。

- 使用 H2 作为主要子主题标题（##）和 H3 作为小节（###）。
- 使用较小的 Markdown 标题（例如，H2 或 H3）进行内容结构，避免使用最大标题（H1），因为它将用于较大报告的标题。
- 将你的内容组织成与现有报告互补但不重叠的不同部分。
- 在向报告中添加相似或相同的小节时，你应该清楚指出新内容与先前子主题报告的现有书面内容之间的差异。例如：

    ### 新标题（类似于现有标题）

    虽然前一节讨论了[主题 A]，但本节将探讨[主题 B]。

"日期"：
假设当前日期是 {datetime.now(timezone.utc).strftime('%Y年%m月%d日')}（如果需要）。

"重要！"：
- 你必须使用以下语言撰写报告：{language}。
- 焦点必须集中在主要主题上！你必须排除任何与它无关的信息！
- 不得有任何引言、结论、摘要或参考文献部分。
- 你必须使用 {report_format.upper()} 格式的文内引用参考文献，并使用放在引用它们的句子或段落末尾的 markdown 超链接，像这样：([文内引用](url))。
- 如果必要，你必须在报告中添加相似或相同的小节时提及现有内容和新内容之间的差异。
- 报告的最小长度应为 {total_words} 字。
- 在整个报告中使用 {tone.value} 语气。

不要添加结论部分。
"""
```

### 7.3 草稿标题生成提示词

```python
@staticmethod
def generate_draft_titles_prompt(
    current_subtopic: str,
    main_topic: str,
    context: str,
    max_subsections: int = 5
) -> str:
    return f"""
"上下文"：
"{context}"

"主要主题和子主题"：
使用最新可用信息，为主要主题：{main_topic} 下的子主题：{current_subtopic} 构建详细报告的草稿部分标题标题。

"任务"：
1. 为子主题报告创建草稿部分标题标题列表。
2. 每个标题应简洁且与子主题相关。
3. 标题不应太高级，但应足够详细以涵盖子主题的主要方面。
4. 使用 markdown 语法作为标题，使用 H3（###），因为 H1 和 H2 将用于较大报告的标题。
5. 确保标题涵盖子主题的主要方面。

"结构和格式化"：
使用 markdown 语法以列表格式提供草稿标题，例如：

### 标题 1
### 标题 2
### 标题 3

"重要！"：
- 焦点必须集中在主要主题上！你必须排除任何与它无关的信息！
- 不得有任何引言、结论、摘要或参考文献部分。
- 专注于创建标题，而不是内容。
"""
```

### 7.4 报告引言生成提示词

```python
@staticmethod
def generate_report_introduction(question: str, research_summary: str = "", language: str = "english", report_format: str = "apa") -> str:
    return f"""{research_summary}\n
使用上述最新信息，为主题 -- {question} 准备详细的报告引言。
- 引言应简洁、结构良好、信息丰富，使用 markdown 语法。
- 由于此引言将是较大报告的一部分，不要包含报告中通常存在的任何其他部分。
- 引言应以适合整个报告的 H1 标题开头。
- 你必须使用 {report_format.upper()} 格式的文内引用参考文献，并使用放在引用它们的句子或段落末尾的 markdown 超链接，像这样：([文内引用](url))。
假设当前日期是 {datetime.now(timezone.utc).strftime('%Y年%m月%d日')}（如果需要）。
- 输出必须是 {language} 语言。
"""
```

### 7.5 报告结论生成提示词

```python
@staticmethod
def generate_report_conclusion(query: str, report_content: str, language: str = "english", report_format: str = "apa") -> str:
    """
    生成简洁的结论，总结研究报告的主要发现和影响。

    参数:
        query (str): 研究任务或问题。
        report_content (str): 研究报告的内容。
        language (str): 结论应撰写的语言。

    返回:
        str: 总结报告主要发现和影响的简洁结论。
    """
    prompt = f"""
    基于以下研究报告和研究任务，请撰写简洁的结论，总结主要发现及其影响：

    研究任务：{query}

    研究报告：{report_content}

    你的结论应该：
    1. 回顾研究要点
    2. 突出最重要的发现
    3. 讨论任何影响或后续步骤
    4. 长度约 2-3 段

    如果报告末尾没有写入"## 结论"部分标题，请将其添加到你的结论顶部。
    你必须使用 {report_format.upper()} 格式的文内引用参考文献，并使用放在引用它们的句子或段落末尾的 markdown 超链接，像这样：([文内引用](url))。

    重要：整个结论必须使用 {language} 语言撰写。

    撰写结论：
    """

    return prompt
```

## 8. 文档处理工具方法

### 8.1 文档美式打印

```python
@staticmethod
def pretty_print_docs(docs: list[Document], top_n: int | None = None) -> str:
    """将文档列表压缩为上下文字符串"""
    return f"\n".join(f"来源：{d.metadata.get('source')}\n"
                      f"标题：{d.metadata.get('title')}\n"
                      f"内容：{d.page_content}\n"
                      for i, d in enumerate(docs)
                      if top_n is None or i < top_n)
```

### 8.2 本地网络文档连接

```python
@staticmethod
def join_local_web_documents(docs_context: str, web_context: str) -> str:
    """将本地网络文档与从互联网抓取的上下文连接"""
    return f"来自本地文档的上下文：{docs_context}\n\n来自网络来源的上下文：{web_context}"
```

## 9. IBM Granite 模型特定提示词

### 9.1 Granite 3.X 模型提示词

```python
class Granite3PromptFamily(PromptFamily):
    """IBM granite 3.X 模型的提示词（3.3 之前）"""

    _DOCUMENTS_PREFIX = "<|start_of_role|>documents<|end_of_role|>\n"
    _DOCUMENTS_SUFFIX = "\n<|end_of_text|>"

    @classmethod
    def pretty_print_docs(cls, docs: list[Document], top_n: int | None = None) -> str:
        if not docs:
            return ""
        all_documents = "\n\n".join([
            f"Document {doc.metadata.get('source', i)}\n" + \
            f"Title: {doc.metadata.get('title')}\n" + \
            doc.page_content
            for i, doc in enumerate(docs)
            if top_n is None or i < top_n
        ])
        return "".join([cls._DOCUMENTS_PREFIX, all_documents, cls._DOCUMENTS_SUFFIX])

    @classmethod
    def join_local_web_documents(cls, docs_context: str | list, web_context: str | list) -> str:
        """使用 Granite 的首选格式连接本地网络文档"""
        if isinstance(docs_context, str) and docs_context.startswith(cls._DOCUMENTS_PREFIX):
            docs_context = docs_context[len(cls._DOCUMENTS_PREFIX):]
        if isinstance(web_context, str) and web_context.endswith(cls._DOCUMENTS_SUFFIX):
            web_context = web_context[:-len(cls._DOCUMENTS_SUFFIX)]
        all_documents = "\n\n".join([docs_context, web_context])
        return "".join([cls._DOCUMENTS_PREFIX, all_documents, cls._DOCUMENTS_SUFFIX])
```

### 9.2 Granite 3.3 模型提示词

```python
class Granite33PromptFamily(PromptFamily):
    """IBM granite 3.3 模型的提示词"""

    _DOCUMENT_TEMPLATE = """<|start_of_role|>document {{"document_id": "{document_id}"}}<|end_of_role|>
{document_content}<|end_of_text|>
"""

    @staticmethod
    def _get_content(doc: Document) -> str:
        doc_content = doc.page_content
        if title := doc.metadata.get("title"):
            doc_content = f"Title: {title}\n{doc_content}"
        return doc_content.strip()

    @classmethod
    def pretty_print_docs(cls, docs: list[Document], top_n: int | None = None) -> str:
        return "\n".join([
            cls._DOCUMENT_TEMPLATE.format(
                document_id=doc.metadata.get("source", i),
                document_content=cls._get_content(doc),
            )
            for i, doc in enumerate(docs)
            if top_n is None or i < top_n
        ])

    @classmethod
    def join_local_web_documents(cls, docs_context: str | list, web_context: str | list) -> str:
        """使用 Granite 的首选格式连接本地网络文档"""
        return "\n\n".join([docs_context, web_context])
```

## 10. 提示词工厂映射

### 10.1 报告类型映射

```python
report_type_mapping = {
    ReportType.ResearchReport.value: "generate_report_prompt",           # 研究报告
    ReportType.ResourceReport.value: "generate_resource_report_prompt",   # 资源报告
    ReportType.OutlineReport.value: "generate_outline_report_prompt",     # 大纲报告
    ReportType.CustomReport.value: "generate_custom_report_prompt",       # 自定义报告
    ReportType.SubtopicReport.value: "generate_subtopic_report_prompt", # 子主题报告
    ReportType.DeepResearch.value: "generate_deep_research_prompt",     # 深度研究报告
}
```

### 10.2 提示词族映射

```python
prompt_family_mapping = {
    PromptFamilyEnum.Default.value: PromptFamily,      # 默认提示词族
    PromptFamilyEnum.Granite.value: GranitePromptFamily,   # Granite 提示词族
    PromptFamilyEnum.Granite3.value: Granite3PromptFamily, # Granite 3 提示词族
    PromptFamilyEnum.Granite31.value: Granite3PromptFamily, # Granite 3.1 提示词族
    PromptFamilyEnum.Granite32.value: Granite3PromptFamily, # Granite 3.2 提示词族
    PromptFamilyEnum.Granite33.value: Granite33PromptFamily, # Granite 3.3 提示词族
}
```

## 总结

GPT Researcher 项目的提示词系统设计得非常全面和灵活，涵盖了：

1. **多种报告类型**：研究报告、资源报告、大纲报告、自定义报告、子主题报告、深度研究报告
2. **MCP 集成**：支持 Model Context Protocol 的工具选择和研究执行
3. **详细报告生成**：包括子主题规划、内容唯一性保证、结构化格式化
4. **多语言支持**：所有报告都支持多语言生成
5. **多种格式支持**：APA 等学术引用格式
6. **模型适配**：针对不同模型（如 IBM Granite）的特定格式优化
7. **源管理**：智能的源选择和整理系统

这个提示词系统为 GPT Researcher 提供了强大而灵活的研究能力，能够适应各种研究需求和报告类型。